# Swift Menubar Rewrite Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Rewrite the cctop macOS menubar app from Rust (egui/wgpu) to Swift/SwiftUI while keeping the TUI and hook binary in Rust.

**Architecture:** The Swift menubar app reads the same `~/.cctop/sessions/*.json` files that cctop-hook writes. No FFI — the JSON file format is the interface contract. The Xcode project lives in `menubar/` subdirectory alongside the existing Cargo project.

**Tech Stack:** Swift 5.9+, SwiftUI (MenuBarExtra), macOS 13+ (Ventura), Xcode 16+, DispatchSource for file watching. Rust stays for cctop-hook and cctop TUI.

---

## Phase 1: Swift Menubar App (MVP)

### Task 1: Create Xcode project and scaffold

**Files:**
- Create: `menubar/CctopMenubar.xcodeproj/` (via Xcode)
- Create: `menubar/CctopMenubar/CctopApp.swift`
- Create: `menubar/CctopMenubar/Info.plist` (auto-generated by Xcode)
- Modify: `.gitignore`

**Step 1: Create Xcode project**

Open Xcode > File > New > Project > macOS > App
- Product Name: `CctopMenubar`
- Interface: SwiftUI
- Language: Swift
- Uncheck "Include Tests"
- Save into `menubar/` subdirectory of the repo

**Step 2: Configure as menubar-only app**

In the Xcode project settings or Info.plist, add:
```xml
<key>LSUIElement</key>
<true/>
```

This hides the dock icon so the app only appears in the menu bar.

**Step 3: Update .gitignore**

Add these lines to the root `.gitignore`:
```
menubar/build/
menubar/CctopMenubar.xcodeproj/xcuserdata/
menubar/CctopMenubar.xcodeproj/project.xcworkspace/xcuserdata/
```

**Step 4: Verify build from command line**

Run:
```bash
xcodebuild build \
    -project menubar/CctopMenubar.xcodeproj \
    -scheme CctopMenubar \
    -configuration Debug \
    -derivedDataPath menubar/build/ \
    CODE_SIGN_IDENTITY="-"
```
Expected: BUILD SUCCEEDED

**Step 5: Commit**

```bash
git add menubar/ .gitignore
git commit -m "feat: scaffold Swift menubar Xcode project"
```

---

### Task 2: Data model — Session struct with Codable

**Files:**
- Create: `menubar/CctopMenubar/Models/Session.swift`
- Create: `menubar/CctopMenubar/Models/SessionStatus.swift`

**Step 1: Write SessionStatus enum with forward-compatible decoding**

```swift
// menubar/CctopMenubar/Models/SessionStatus.swift
import SwiftUI

enum SessionStatus: String, Codable {
    case idle
    case working
    case waitingPermission = "waiting_permission"
    case waitingInput = "waiting_input"
    case needsAttention = "needs_attention"

    // Forward compatibility: unknown statuses fall back to needsAttention
    // (matches Rust's #[serde(other)] behavior)
    init(from decoder: Decoder) throws {
        let raw = try decoder.singleValueContainer().decode(String.self)
        self = SessionStatus(rawValue: raw) ?? .needsAttention
    }

    var needsAttention: Bool {
        switch self {
        case .waitingPermission, .waitingInput, .needsAttention: return true
        default: return false
        }
    }

    var color: Color {
        switch self {
        case .waitingPermission: return .red
        case .waitingInput, .needsAttention: return .orange
        case .working: return .green
        case .idle: return .gray
        }
    }

    var label: String {
        switch self {
        case .waitingPermission: return "PERMISSION"
        case .waitingInput, .needsAttention: return "WAITING"
        case .working: return "WORKING"
        case .idle: return "IDLE"
        }
    }

    var sortOrder: Int {
        switch self {
        case .waitingPermission: return 0
        case .waitingInput, .needsAttention: return 1
        case .working: return 2
        case .idle: return 3
        }
    }
}
```

**Step 2: Write Session struct**

```swift
// menubar/CctopMenubar/Models/Session.swift
import Foundation

struct TerminalInfo: Codable {
    let program: String
    let sessionId: String?
    let tty: String?

    enum CodingKeys: String, CodingKey {
        case program
        case sessionId = "session_id"
        case tty
    }
}

struct Session: Codable, Identifiable {
    let sessionId: String
    let projectPath: String
    let projectName: String
    var branch: String
    var status: SessionStatus
    var lastPrompt: String?
    var lastActivity: Date
    var startedAt: Date
    var terminal: TerminalInfo
    var pid: UInt32?
    var lastTool: String?
    var lastToolDetail: String?
    var notificationMessage: String?
    var contextCompacted: Bool?

    var id: String { sessionId }

    enum CodingKeys: String, CodingKey {
        case sessionId = "session_id"
        case projectPath = "project_path"
        case projectName = "project_name"
        case branch, status
        case lastPrompt = "last_prompt"
        case lastActivity = "last_activity"
        case startedAt = "started_at"
        case terminal, pid
        case lastTool = "last_tool"
        case lastToolDetail = "last_tool_detail"
        case notificationMessage = "notification_message"
        case contextCompacted = "context_compacted"
    }

    var relativeTime: String {
        let seconds = Int(-lastActivity.timeIntervalSinceNow)
        if seconds < 0 { return "just now" }
        if seconds >= 86400 { return "\(seconds / 86400)d ago" }
        if seconds >= 3600 { return "\(seconds / 3600)h ago" }
        if seconds >= 60 { return "\(seconds / 60)m ago" }
        return "\(seconds)s ago"
    }

    var contextLine: String? {
        switch status {
        case .idle: return nil
        case .waitingPermission:
            return notificationMessage ?? "Permission needed"
        case .waitingInput, .needsAttention:
            return lastPrompt.map { "\"\(String($0.prefix(36)))\"" }
        case .working:
            if let tool = lastTool {
                return formatToolDisplay(tool: tool, detail: lastToolDetail)
            }
            return lastPrompt.map { "\"\(String($0.prefix(36)))\"" }
        }
    }

    var isAlive: Bool {
        guard let pid else { return true }
        return kill(Int32(pid), 0) == 0
    }

    private func formatToolDisplay(tool: String, detail: String?) -> String {
        switch (tool, detail) {
        case ("Bash", let cmd?): return "Running: \(cmd.prefix(30))"
        case ("Edit", let path?): return "Editing \(URL(fileURLWithPath: path).lastPathComponent)"
        case ("Write", let path?): return "Writing \(URL(fileURLWithPath: path).lastPathComponent)"
        case ("Read", let path?): return "Reading \(URL(fileURLWithPath: path).lastPathComponent)"
        case ("Grep", let pat?): return "Searching: \(pat.prefix(30))"
        case ("Glob", let pat?): return "Finding: \(pat.prefix(30))"
        case ("WebFetch", let url?): return "Fetching: \(url.prefix(30))"
        case ("WebSearch", let query?): return "Searching: \(query.prefix(30))"
        case ("Task", let desc?): return "Task: \(desc.prefix(30))"
        case (let name, let detail?): return "\(name): \(detail.prefix(30))"
        case (let name, nil): return "\(name)..."
        }
    }
}
```

**Step 3: Verify it compiles**

Run:
```bash
xcodebuild build -project menubar/CctopMenubar.xcodeproj -scheme CctopMenubar -configuration Debug -derivedDataPath menubar/build/ CODE_SIGN_IDENTITY="-"
```
Expected: BUILD SUCCEEDED

**Step 4: Commit**

```bash
git add menubar/CctopMenubar/Models/
git commit -m "feat: add Session and SessionStatus data model with Codable"
```

---

### Task 3: Session manager with file watching

**Files:**
- Create: `menubar/CctopMenubar/Services/SessionManager.swift`

**Step 1: Add shared date decoder (handles fractional seconds)**

Rust's `chrono::DateTime<Utc>` serializes with variable precision — sometimes `"2026-02-08T12:00:00Z"`, sometimes `"2026-02-08T12:00:00.123456Z"`. Swift's built-in `.iso8601` decoder rejects fractional seconds, so we need a custom decoder.

Add this to `Session.swift` (or a new `DateDecoding.swift`):
```swift
extension JSONDecoder {
    static let sessionDecoder: JSONDecoder = {
        let decoder = JSONDecoder()
        let withFractional = ISO8601DateFormatter()
        withFractional.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        let withoutFractional = ISO8601DateFormatter()
        withoutFractional.formatOptions = [.withInternetDateTime]
        decoder.dateDecodingStrategy = .custom { decoder in
            let container = try decoder.singleValueContainer()
            let string = try container.decode(String.self)
            if let date = withFractional.date(from: string) { return date }
            if let date = withoutFractional.date(from: string) { return date }
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Invalid date: \(string)")
        }
        return decoder
    }()
}
```

**Step 2: Write SessionManager**

```swift
// menubar/CctopMenubar/Services/SessionManager.swift
import Foundation

@MainActor
class SessionManager: ObservableObject {
    @Published var sessions: [Session] = []

    private let sessionsDir: URL
    private var source: DispatchSourceFileSystemObject?

    init() {
        self.sessionsDir = FileManager.default.homeDirectoryForCurrentUser
            .appendingPathComponent(".cctop/sessions")
        loadSessions()
        startWatching()
    }

    func loadSessions() {
        guard let files = try? FileManager.default.contentsOfDirectory(
            at: sessionsDir,
            includingPropertiesForKeys: nil
        ) else {
            sessions = []
            return
        }

        let allDecoded = files
            .filter { $0.pathExtension == "json" && !$0.lastPathComponent.hasSuffix(".tmp") }
            .compactMap { url -> (URL, Session)? in
                guard let data = try? Data(contentsOf: url),
                      let session = try? JSONDecoder.sessionDecoder.decode(Session.self, from: data)
                else { return nil }
                return (url, session)
            }
        sessions = allDecoded.filter { $0.1.isAlive }.map(\.1)
        // Clean up dead session files
        for (url, session) in allDecoded where !session.isAlive {
            try? FileManager.default.removeItem(at: url)
        }
    }

    private func startWatching() {
        try? FileManager.default.createDirectory(at: sessionsDir, withIntermediateDirectories: true)

        let fd = open(sessionsDir.path, O_EVTONLY)
        guard fd >= 0 else { return }

        let source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fd,
            eventMask: .write,
            queue: .main
        )
        source.setEventHandler { [weak self] in
            Task { @MainActor in
                self?.loadSessions()
            }
        }
        source.setCancelHandler { close(fd) }
        source.resume()
        self.source = source
    }

    deinit {
        source?.cancel()
    }
}
```

**Step 3: Verify it compiles**

Run:
```bash
xcodebuild build -project menubar/CctopMenubar.xcodeproj -scheme CctopMenubar -configuration Debug -derivedDataPath menubar/build/ CODE_SIGN_IDENTITY="-"
```
Expected: BUILD SUCCEEDED

**Step 4: Commit**

```bash
git add menubar/CctopMenubar/Services/
git commit -m "feat: add SessionManager with DispatchSource file watching"
```

---

### Task 4: MenuBarExtra entry point with popup views

**Files:**
- Modify: `menubar/CctopMenubar/CctopApp.swift` (replace Xcode-generated boilerplate)
- Create: `menubar/CctopMenubar/Views/PopupView.swift`
- Create: `menubar/CctopMenubar/Views/HeaderView.swift`
- Create: `menubar/CctopMenubar/Views/SessionCardView.swift`
- Create: `menubar/CctopMenubar/Views/StatusChip.swift`

**Step 1: Delete Xcode-generated ContentView.swift if it exists**

Remove the default `ContentView.swift` that Xcode generates.

**Step 2: Write StatusChip (shared component)**

```swift
// menubar/CctopMenubar/Views/StatusChip.swift
import SwiftUI

struct StatusChip: View {
    let count: Int
    let color: Color

    var body: some View {
        if count > 0 {
            HStack(spacing: 4) {
                Circle().fill(color).frame(width: 5, height: 5)
                Text("\(count)").font(.system(size: 10)).foregroundStyle(color)
            }
            .padding(.horizontal, 6)
            .padding(.vertical, 2)
            .background(color.opacity(0.1))
            .clipShape(Capsule())
            .overlay(Capsule().stroke(color.opacity(0.25), lineWidth: 1))
        }
    }
}
```

**Step 3: Write HeaderView**

```swift
// menubar/CctopMenubar/Views/HeaderView.swift
import SwiftUI

struct HeaderView: View {
    let sessions: [Session]

    var body: some View {
        HStack {
            RoundedRectangle(cornerRadius: 6)
                .fill(.orange)
                .frame(width: 20, height: 20)
                .overlay(Text("C").font(.system(size: 12, weight: .bold)).foregroundStyle(.white))
            Text("cctop").font(.system(size: 14, weight: .semibold))
            Spacer()
            StatusChip(count: sessions.filter { $0.status.needsAttention }.count, color: .orange)
            StatusChip(count: sessions.filter { $0.status == .working }.count, color: .green)
            StatusChip(count: sessions.filter { $0.status == .idle }.count, color: .gray)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
    }
}
```

**Step 4: Write SessionCardView**

```swift
// menubar/CctopMenubar/Views/SessionCardView.swift
import SwiftUI

struct SessionCardView: View {
    let session: Session
    @State private var isHovered = false

    var body: some View {
        HStack(spacing: 8) {
            Circle()
                .fill(session.status.color)
                .frame(width: 9, height: 9)

            VStack(alignment: .leading, spacing: 3) {
                HStack(spacing: 6) {
                    Text(session.projectName)
                        .font(.system(size: 13))
                        .foregroundStyle(.primary)
                    Text(session.branch)
                        .font(.system(size: 10, design: .monospaced))
                        .foregroundStyle(.tertiary)
                        .padding(.horizontal, 5)
                        .padding(.vertical, 1)
                        .background(Color.primary.opacity(0.06))
                        .clipShape(RoundedRectangle(cornerRadius: 4))
                }
                if let context = session.contextLine {
                    Text(context)
                        .font(.system(size: 11))
                        .foregroundStyle(.secondary)
                        .lineLimit(1)
                }
            }

            Spacer()

            VStack(alignment: .trailing, spacing: 4) {
                Text(session.relativeTime)
                    .font(.system(size: 10))
                    .foregroundStyle(.tertiary)
                Text(session.status.label)
                    .font(.system(size: 9))
                    .foregroundStyle(session.status.color)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 1)
                    .background(session.status.color.opacity(0.1))
                    .clipShape(RoundedRectangle(cornerRadius: 4))
                    .overlay(RoundedRectangle(cornerRadius: 4).stroke(session.status.color.opacity(0.25), lineWidth: 1))
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 10)
        .background(isHovered ? Color.primary.opacity(0.06) : Color.primary.opacity(0.03))
        .clipShape(RoundedRectangle(cornerRadius: 10))
        .overlay(RoundedRectangle(cornerRadius: 10).stroke(Color.primary.opacity(isHovered ? 0.1 : 0.06), lineWidth: 1))
        .onHover { isHovered = $0 }
        .animation(.easeOut(duration: 0.15), value: isHovered)
    }
}
```

**Step 5: Write PopupView**

```swift
// menubar/CctopMenubar/Views/PopupView.swift
import SwiftUI

struct PopupView: View {
    let sessions: [Session]

    var body: some View {
        VStack(spacing: 0) {
            HeaderView(sessions: sessions)
            Divider()
            if sessions.isEmpty {
                Text("No active sessions")
                    .foregroundStyle(.secondary)
                    .frame(maxWidth: .infinity, minHeight: 44)
            } else {
                ScrollView {
                    LazyVStack(spacing: 4) {
                        ForEach(sessions.sorted {
                            ($0.status.sortOrder, $1.lastActivity) < ($1.status.sortOrder, $0.lastActivity)
                        }) { session in
                            SessionCardView(session: session)
                        }
                    }
                    .padding(8)
                }
                .frame(maxHeight: 520)
            }
            Divider()
            HStack {
                Button("Quit") { NSApplication.shared.terminate(nil) }
                    .buttonStyle(.plain)
                    .font(.system(size: 11))
                    .foregroundStyle(.secondary)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 8)
                Spacer()
            }
        }
    }
}
```

**Step 6: Replace CctopApp.swift with MenuBarExtra**

```swift
// menubar/CctopMenubar/CctopApp.swift
import SwiftUI

@main
struct CctopApp: App {
    @StateObject private var sessionManager = SessionManager()

    var body: some Scene {
        MenuBarExtra {
            PopupView(sessions: sessionManager.sessions)
                .frame(width: 320)
        } label: {
            let count = sessionManager.sessions.filter { $0.status.needsAttention }.count
            if count > 0 {
                Text("CC (\(count))")
            } else {
                Text("CC")
            }
        }
        .menuBarExtraStyle(.window)
    }
}
```

**Step 7: Build and verify**

Run:
```bash
xcodebuild build -project menubar/CctopMenubar.xcodeproj -scheme CctopMenubar -configuration Debug -derivedDataPath menubar/build/ CODE_SIGN_IDENTITY="-"
```
Expected: BUILD SUCCEEDED

**Step 8: Launch and manually verify**

Run:
```bash
open menubar/build/Build/Products/Debug/CctopMenubar.app
```
Expected: "CC" appears in the menu bar. Click it to see the popup. If you have active Claude Code sessions, they should appear.

**Step 9: Commit**

```bash
git add menubar/CctopMenubar/CctopApp.swift menubar/CctopMenubar/Views/
git commit -m "feat: add MenuBarExtra entry point with popup views"
```

---

### Task 5: Pulsing animation for attention dots

**Files:**
- Modify: `menubar/CctopMenubar/Views/SessionCardView.swift`

**Step 1: Add pulsing animation to the status dot**

In `SessionCardView`, replace the static `Circle()` with:

```swift
Circle()
    .fill(session.status.color)
    .frame(width: 9, height: 9)
    .opacity(session.status.needsAttention ? pulsingOpacity : 1.0)

// Add as a property on SessionCardView:
@State private var pulsing = false

var pulsingOpacity: Double {
    pulsing ? 1.0 : 0.6
}

// Add .onAppear and .onChange to the card's top-level HStack:
.onAppear {
    if session.status.needsAttention {
        withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
            pulsing = true
        }
    }
}
.onChange(of: session.status) { _, newStatus in
    if newStatus.needsAttention {
        withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
            pulsing = true
        }
    } else {
        withAnimation(.default) { pulsing = false }
    }
}
```

**Step 2: Build and verify**

Run the app. Sessions with `waiting_permission` or `waiting_input` status should have pulsing dots.

**Step 3: Commit**

```bash
git add menubar/CctopMenubar/Views/SessionCardView.swift
git commit -m "feat: add pulsing animation for attention status dots"
```

---

### Task 6: Focus terminal on session click

**Files:**
- Create: `menubar/CctopMenubar/Services/FocusTerminal.swift`
- Modify: `menubar/CctopMenubar/Views/PopupView.swift`

**Step 1: Port focus logic from focus.rs**

The Rust `focus.rs` uses AppleScript to activate terminal windows. Port the same approach:

```swift
// menubar/CctopMenubar/Services/FocusTerminal.swift
import AppKit

func focusTerminal(session: Session) {
    let program = session.terminal.program.lowercased()

    if program.contains("code") || program.contains("cursor") {
        // VS Code / Cursor: use CLI --goto
        let cli = program.contains("cursor") ? "cursor" : "code"
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
        process.arguments = [cli, "--goto", session.projectPath]
        try? process.run()
    } else if program.contains("iterm") {
        // iTerm2: AppleScript
        let script = """
        tell application "iTerm"
            activate
            tell current window
                select
            end tell
        end tell
        """
        if let appleScript = NSAppleScript(source: script) {
            var error: NSDictionary?
            appleScript.executeAndReturnError(&error)
        }
    } else {
        // Generic: try to activate by name
        if let app = NSWorkspace.shared.runningApplications.first(where: {
            $0.localizedName?.lowercased().contains(program) == true
        }) {
            app.activate()
        } else {
            NSWorkspace.shared.open(URL(fileURLWithPath: session.projectPath))
        }
    }
}
```

**Step 2: Wire up click in PopupView**

In `PopupView`, update the ForEach:
```swift
SessionCardView(session: session)
    .onTapGesture { focusSession(session) }
```

Add method:
```swift
private func focusSession(_ session: Session) {
    focusTerminal(session: session)
    // Dismiss the popup by deactivating the app
    NSApp.deactivate()
}
```

**Step 3: Build, test with a real session, commit**

```bash
git add menubar/CctopMenubar/Services/FocusTerminal.swift menubar/CctopMenubar/Views/PopupView.swift
git commit -m "feat: focus terminal window on session card click"
```

---

### Task 7: Update CLAUDE.md with Swift development workflow

**Files:**
- Modify: `CLAUDE.md`

**Why now:** After the MVP is functional (Tasks 1-6), future sessions need to know about the Swift menubar. This ensures any Claude session working on this repo knows: (a) the menubar is now Swift/SwiftUI, (b) how to build and test it, (c) the project structure.

**Step 1: Add Swift menubar section to CLAUDE.md**

Add after the existing "Architecture" section:

```markdown
### Swift Menubar App

The macOS menubar app is built with Swift/SwiftUI (replacing the previous Rust/egui implementation).

**Location:** `menubar/`

**Build:**
\`\`\`bash
# Build from command line
xcodebuild build -project menubar/CctopMenubar.xcodeproj -scheme CctopMenubar -configuration Debug -derivedDataPath menubar/build/ CODE_SIGN_IDENTITY="-"

# Run the app
open menubar/build/Build/Products/Debug/CctopMenubar.app

# Run tests
xcodebuild test -project menubar/CctopMenubar.xcodeproj -scheme CctopMenubar -configuration Debug -derivedDataPath menubar/build/
\`\`\`

**Visual verification:** Open the Xcode project and use SwiftUI Previews (Canvas) for instant visual feedback. All views have `#Preview` blocks with mock data.

**Data flow:** The Swift app reads `~/.cctop/sessions/*.json` files written by `cctop-hook` (Rust). The JSON file format is the interface contract — no FFI.

**Key files:**
- `menubar/CctopMenubar/CctopApp.swift` — MenuBarExtra entry point
- `menubar/CctopMenubar/Views/PopupView.swift` — Main popup layout
- `menubar/CctopMenubar/Views/SessionCardView.swift` — Session card component
- `menubar/CctopMenubar/Models/Session.swift` — Session data model (Codable)
- `menubar/CctopMenubar/Services/SessionManager.swift` — File watching + session loading

**Claude Code MCP tools for Swift:**
\`\`\`bash
# Build/test from Claude Code (if XcodeBuildMCP is configured)
claude mcp add XcodeBuildMCP -- npx -y xcodebuildmcp@beta mcp
# Xcode bridge for Preview screenshots
claude mcp add --transport stdio xcode -- xcrun mcpbridge
\`\`\`
```

**Step 2: Update the Architecture diagram**

Replace or update the architecture tree to include `menubar/` and mark `src/menubar/` as removed.

**Step 3: Update Development Commands section**

Add the Swift build/test commands alongside the existing Rust commands.

**Step 4: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: update CLAUDE.md with Swift menubar development workflow"
```

---

## Phase 2: Polish and Integration

### Task 8: Add Xcode Previews for all views

**Files:**
- Modify: each view file to add `#Preview` blocks with mock data

**Step 1: Add mock data factory**

Create `menubar/CctopMenubar/Models/Session+Mock.swift`:

```swift
import Foundation

extension Session {
    static func mock(
        id: String = "test-123",
        project: String = "cctop",
        branch: String = "main",
        status: SessionStatus = .idle,
        lastPrompt: String? = nil,
        lastTool: String? = nil,
        lastToolDetail: String? = nil,
        notificationMessage: String? = nil
    ) -> Session {
        Session(
            sessionId: id,
            projectPath: "/Users/test/projects/\(project)",
            projectName: project,
            branch: branch,
            status: status,
            lastPrompt: lastPrompt,
            lastActivity: Date(),
            startedAt: Date(),
            terminal: TerminalInfo(program: "Code", sessionId: nil, tty: nil),
            pid: nil,
            lastTool: lastTool,
            lastToolDetail: lastToolDetail,
            notificationMessage: notificationMessage,
            contextCompacted: false
        )
    }

    static let mockSessions: [Session] = [
        .mock(id: "1", project: "cctop", branch: "main", status: .waitingPermission, notificationMessage: "Allow Bash: npm test"),
        .mock(id: "2", project: "my-app", branch: "feature/auth", status: .working, lastTool: "Edit", lastToolDetail: "/src/auth.ts"),
        .mock(id: "3", project: "api-server", branch: "fix/timeout", status: .waitingInput, lastPrompt: "Should I also update the retry logic?"),
        .mock(id: "4", project: "docs", branch: "main", status: .idle),
    ]
}
```

**Step 2: Add #Preview to each view**

Add to bottom of `PopupView.swift`:
```swift
#Preview("With sessions") {
    PopupView(sessions: Session.mockSessions).frame(width: 320)
}
#Preview("Empty") {
    PopupView(sessions: []).frame(width: 320)
}
```

Add to bottom of `SessionCardView.swift`:
```swift
#Preview("Working") {
    SessionCardView(session: .mock(status: .working, lastTool: "Bash", lastToolDetail: "cargo test"))
        .frame(width: 300).padding()
}
#Preview("Permission") {
    SessionCardView(session: .mock(status: .waitingPermission, notificationMessage: "Allow Bash: rm -rf"))
        .frame(width: 300).padding()
}
#Preview("Idle") {
    SessionCardView(session: .mock(status: .idle))
        .frame(width: 300).padding()
}
```

**Step 3: Open in Xcode and verify previews render**

```bash
open menubar/CctopMenubar.xcodeproj
```
Navigate to any view file and check that the Canvas shows the preview.

**Step 4: Commit**

```bash
git add menubar/CctopMenubar/
git commit -m "feat: add Xcode Previews with mock data for all views"
```

---

### Task 9: Add unit tests for data model

**Files:**
- Create: `menubar/CctopMenubarTests/` test target (via Xcode: File > New > Target > macOS > Unit Testing Bundle)
- Create: `menubar/CctopMenubarTests/SessionTests.swift`
- Create: `menubar/CctopMenubarTests/SessionStatusTests.swift`

**Step 1: Add test target in Xcode**

File > New > Target > macOS > Unit Testing Bundle
- Name: `CctopMenubarTests`
- Target to be Tested: `CctopMenubar`

**Step 2: Write SessionStatus tests**

```swift
// menubar/CctopMenubarTests/SessionStatusTests.swift
import XCTest
@testable import CctopMenubar

final class SessionStatusTests: XCTestCase {
    func testKnownStatusDecoding() throws {
        let json = "\"working\""
        let status = try JSONDecoder().decode(SessionStatus.self, from: Data(json.utf8))
        XCTAssertEqual(status, .working)
    }

    func testUnknownStatusFallsBackToNeedsAttention() throws {
        let json = "\"some_future_status\""
        let status = try JSONDecoder().decode(SessionStatus.self, from: Data(json.utf8))
        XCTAssertEqual(status, .needsAttention)
    }

    func testSnakeCaseDecoding() throws {
        let json = "\"waiting_permission\""
        let status = try JSONDecoder().decode(SessionStatus.self, from: Data(json.utf8))
        XCTAssertEqual(status, .waitingPermission)
    }

    func testNeedsAttentionFlag() {
        XCTAssertTrue(SessionStatus.waitingPermission.needsAttention)
        XCTAssertTrue(SessionStatus.waitingInput.needsAttention)
        XCTAssertTrue(SessionStatus.needsAttention.needsAttention)
        XCTAssertFalse(SessionStatus.working.needsAttention)
        XCTAssertFalse(SessionStatus.idle.needsAttention)
    }

    func testSortOrder() {
        XCTAssertLessThan(SessionStatus.waitingPermission.sortOrder, SessionStatus.working.sortOrder)
        XCTAssertLessThan(SessionStatus.working.sortOrder, SessionStatus.idle.sortOrder)
    }
}
```

**Step 3: Write Session JSON roundtrip tests**

```swift
// menubar/CctopMenubarTests/SessionTests.swift
import XCTest
@testable import CctopMenubar

final class SessionTests: XCTestCase {
    func testDecodesRealSessionJSON() throws {
        let json = """
        {
            "session_id": "abc-123",
            "project_path": "/Users/test/projects/myapp",
            "project_name": "myapp",
            "branch": "main",
            "status": "working",
            "last_prompt": "Fix the bug",
            "last_activity": "2026-02-08T12:00:00Z",
            "started_at": "2026-02-08T11:00:00Z",
            "terminal": {"program": "Code", "session_id": null, "tty": null},
            "pid": 12345,
            "last_tool": "Bash",
            "last_tool_detail": "npm test",
            "notification_message": null,
            "context_compacted": false
        }
        """
        let session = try JSONDecoder.sessionDecoder.decode(Session.self, from: Data(json.utf8))

        XCTAssertEqual(session.sessionId, "abc-123")
        XCTAssertEqual(session.projectName, "myapp")
        XCTAssertEqual(session.status, .working)
        XCTAssertEqual(session.lastTool, "Bash")
        XCTAssertEqual(session.pid, 12345)
    }

    func testDecodesDateWithFractionalSeconds() throws {
        let json = """
        {
            "session_id": "frac-test",
            "project_path": "/tmp",
            "project_name": "test",
            "branch": "main",
            "status": "idle",
            "last_activity": "2026-02-08T12:00:00.123456Z",
            "started_at": "2026-02-08T11:00:00Z",
            "terminal": {"program": "Code"}
        }
        """
        let session = try JSONDecoder.sessionDecoder.decode(Session.self, from: Data(json.utf8))
        XCTAssertEqual(session.sessionId, "frac-test")
    }

    func testContextLineIdle() {
        let session = Session.mock(status: .idle)
        XCTAssertNil(session.contextLine)
    }

    func testContextLineWorking() {
        let session = Session.mock(status: .working, lastTool: "Bash", lastToolDetail: "npm test")
        XCTAssertEqual(session.contextLine, "Running: npm test")
    }

    func testContextLinePermission() {
        let session = Session.mock(status: .waitingPermission, notificationMessage: "Allow Bash: rm -rf /")
        XCTAssertEqual(session.contextLine, "Allow Bash: rm -rf /")
    }

    func testContextLinePermissionDefault() {
        let session = Session.mock(status: .waitingPermission)
        XCTAssertEqual(session.contextLine, "Permission needed")
    }
}
```

**Step 4: Run tests**

```bash
xcodebuild test -project menubar/CctopMenubar.xcodeproj -scheme CctopMenubar -configuration Debug -derivedDataPath menubar/build/
```
Expected: All tests pass.

**Step 5: Commit**

```bash
git add menubar/CctopMenubarTests/
git commit -m "test: add unit tests for Session and SessionStatus"
```

---

### Task 10: Update run-hook.sh for Homebrew PATH

**Files:**
- Modify: `plugins/cctop/hooks/run-hook.sh`

**Step 1: Add PATH-based fallback**

```sh
#!/bin/sh
# run-hook.sh - Locate and run cctop-hook binary
# Shipped with the cctop Claude Code plugin.
# Checks common install locations and forwards the hook event.

EVENT="$1"

if [ -x "$HOME/.cargo/bin/cctop-hook" ]; then
    exec "$HOME/.cargo/bin/cctop-hook" "$EVENT"
elif [ -x "$HOME/.local/bin/cctop-hook" ]; then
    exec "$HOME/.local/bin/cctop-hook" "$EVENT"
elif command -v cctop-hook >/dev/null 2>&1; then
    exec cctop-hook "$EVENT"
fi
```

**Step 2: Test that existing behavior is preserved**

```bash
echo '{"session_id":"test-path","cwd":"/tmp","hook_event_name":"SessionStart"}' | ~/.cargo/bin/cctop-hook SessionStart
cat ~/.cctop/sessions/test-path.json | python3 -m json.tool
rm ~/.cctop/sessions/test-path.json
```

**Step 3: Commit**

```bash
git add plugins/cctop/hooks/run-hook.sh
git commit -m "fix: add PATH-based fallback for Homebrew-installed cctop-hook"
```

---

## Phase 3: Bundle and Distribution

### Task 11: Create bundle script and update release workflow for hybrid .app

**Files:**
- Create: `scripts/bundle-macos.sh` (replaces old Rust-only bundle script)
- Modify: `.github/workflows/release.yml`

**Step 1: Back up the old bundle script**

```bash
mv scripts/bundle-macos.sh scripts/bundle-macos.sh.bak
```

**Step 2: Write the new bundle script with CLI flags**

The script supports `--skip-build` and `--target` flags for CI usage:

```bash
#!/bin/bash
set -euo pipefail

# bundle-macos.sh - Build and bundle the hybrid Swift + Rust cctop.app

SKIP_BUILD=false
TARGET=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --skip-build) SKIP_BUILD=true; shift ;;
        --target) TARGET="$2"; shift 2 ;;
        *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
done

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
BUILD_DIR="$REPO_ROOT/dist"

if [ "$SKIP_BUILD" = false ]; then
    echo "==> Building Rust binaries..."
    if [ -n "$TARGET" ]; then
        cargo build --release --manifest-path "$REPO_ROOT/Cargo.toml" --target "$TARGET"
        RUST_BIN="$REPO_ROOT/target/$TARGET/release"
    else
        cargo build --release --manifest-path "$REPO_ROOT/Cargo.toml"
        RUST_BIN="$REPO_ROOT/target/release"
    fi

    echo "==> Building Swift menubar app..."
    XCODE_ARCHS=""
    case "$TARGET" in
        aarch64-apple-darwin) XCODE_ARCHS="arm64" ;;
        x86_64-apple-darwin) XCODE_ARCHS="x86_64" ;;
        *) XCODE_ARCHS="$(uname -m)" ;;
    esac
    xcodebuild build \
        -project "$REPO_ROOT/menubar/CctopMenubar.xcodeproj" \
        -scheme CctopMenubar \
        -configuration Release \
        -derivedDataPath "$REPO_ROOT/menubar/build/" \
        CODE_SIGN_IDENTITY="-" \
        ARCHS="$XCODE_ARCHS" \
        ONLY_ACTIVE_ARCH=NO
else
    if [ -n "$TARGET" ]; then
        RUST_BIN="$REPO_ROOT/target/$TARGET/release"
    else
        RUST_BIN="$REPO_ROOT/target/release"
    fi
fi

echo "==> Assembling .app bundle..."
rm -rf "$BUILD_DIR"
mkdir -p "$BUILD_DIR"

APP="$BUILD_DIR/cctop.app"
cp -R "$REPO_ROOT/menubar/build/Build/Products/Release/CctopMenubar.app" "$APP"

# Inject Rust binaries
cp "$RUST_BIN/cctop" "$APP/Contents/MacOS/cctop"
cp "$RUST_BIN/cctop-hook" "$APP/Contents/MacOS/cctop-hook"

# Strip binaries
strip "$APP/Contents/MacOS/cctop"
strip "$APP/Contents/MacOS/cctop-hook"

# Ad-hoc re-sign
codesign --force --deep --sign - "$APP"

echo "==> Packaging..."
cd "$BUILD_DIR"
ditto -c -k --sequesterRsrc --keepParent cctop.app cctop-macOS.zip

SIZE=$(du -sh cctop.app | cut -f1)
echo "==> Done! App size: $SIZE"
echo "   App:  $APP"
echo "   Zip:  $BUILD_DIR/cctop-macOS.zip"
```

**Step 3: Make executable and test**

```bash
chmod +x scripts/bundle-macos.sh
./scripts/bundle-macos.sh
open dist/cctop.app
```
Expected: App launches, shows "CC" in menu bar, popup works, cctop-hook is accessible inside the bundle.

**Step 4: Update release.yml**

Update the release workflow to:
- Remove references to `cctop-menubar` binary
- Ensure the Swift build step runs before bundling
- Use `ditto` instead of `zip -r` for the archive

**Step 5: Commit**

```bash
git add scripts/bundle-macos.sh .github/workflows/release.yml
git commit -m "feat: add hybrid Swift+Rust bundle script and update release workflow"
```

---

### Task 12: Create custom Homebrew tap

**Files (in a separate repo: st0012/homebrew-cctop):**
- Create: `Casks/cctop.rb`

**Step 1: Create the tap repo on GitHub**

Create `github.com/st0012/homebrew-cctop` (public repo).

**Step 2: Write the Cask formula**

```ruby
# Casks/cctop.rb
cask "cctop" do
  version "0.2.0"

  on_arm do
    url "https://github.com/st0012/cctop/releases/download/v#{version}/cctop-macOS-arm64.zip"
    sha256 "REPLACE_WITH_ARM64_SHA256"
  end
  on_intel do
    url "https://github.com/st0012/cctop/releases/download/v#{version}/cctop-macOS-x86_64.zip"
    sha256 "REPLACE_WITH_X86_64_SHA256"
  end

  name "cctop"
  desc "Monitor Claude Code sessions from the macOS menu bar"
  homepage "https://github.com/st0012/cctop"

  app "cctop.app"
  binary "#{appdir}/cctop.app/Contents/MacOS/cctop"
  binary "#{appdir}/cctop.app/Contents/MacOS/cctop-hook"

  zap trash: [
    "~/.cctop",
  ]
end
```

**Step 3: Push and test**

```bash
brew tap st0012/cctop
brew install --cask cctop
```

Note: This requires a GitHub Release with the zip artifact first. Create a release from the bundle-swift.sh output.

---

### Task 13: Rust cleanup — remove menubar code and dependencies

**Files:**
- Delete: `src/menubar/` (all 7 files)
- Delete: `src/bin/cctop_menubar.rs`
- Modify: `src/lib.rs` — remove `pub mod menubar;`
- Modify: `Cargo.toml` — remove `[[bin]] name = "cctop-menubar"` and `[target.'cfg(target_os = "macos")'.dependencies]`

**Step 1: Remove menubar module from lib.rs**

Remove the line `pub mod menubar;` from `src/lib.rs`.

**Step 2: Remove menubar binary from Cargo.toml**

Remove the section:
```toml
[[bin]]
name = "cctop-menubar"
path = "src/bin/cctop_menubar.rs"
```

**Step 3: Remove macOS-specific dependencies from Cargo.toml**

Remove the entire section:
```toml
[target.'cfg(target_os = "macos")'.dependencies]
tray-icon = "0.19"
tao = "0.30"
egui = "0.29"
egui-wgpu = "0.29"
wgpu = "22.0"
raw-window-handle = "0.6"
pollster = "0.4"
objc2 = "0.5"
image = "0.25"
```

Remove `image = "0.25"` from `[dev-dependencies]` — the snapshot tests in `src/menubar/snapshot.rs` are being deleted.

**Step 4: Delete menubar source files**

```bash
rm -rf src/menubar/
rm src/bin/cctop_menubar.rs
```

**Step 5: Verify no code references menubar**

```bash
grep -r "menubar" src/ --include="*.rs"
# Expected: no matches
```

**Step 6: Verify Rust builds still work**

```bash
cargo build
cargo test
```
Expected: Both succeed. Only `cctop` (TUI) and `cctop-hook` binaries are built.

**Step 7: Commit**

```bash
git add -A
git commit -m "refactor: remove Rust menubar code (replaced by Swift)"
```

---

### Task 14: Finalize CLAUDE.md — remove old menubar docs, update architecture

**Files:**
- Modify: `CLAUDE.md`

**Why now:** After Rust cleanup (Task 13), the old menubar architecture docs in CLAUDE.md are stale and misleading. Update them so future sessions don't reference deleted files.

**Step 1: Remove old menubar references**

Remove or update:
- `src/menubar/` entries from the Architecture tree
- `src/bin/cctop_menubar.rs` reference
- The `cctop-menubar` binary description
- The "Visual Snapshot Testing" section (replaced by Xcode Previews)
- Old snapshot commands (`cargo test snapshot`)
- Any references to egui, wgpu, tao, tray-icon

**Step 2: Update Architecture tree**

```
cctop/
├── src/
│   ├── main.rs        # CLI entry point (TUI)
│   ├── lib.rs         # Library exports
│   ├── config.rs      # Config loading
│   ├── session.rs     # Session struct and status handling
│   ├── tui.rs         # Ratatui TUI implementation
│   ├── focus.rs       # Terminal focus
│   ├── git.rs         # Git branch detection
│   ├── watcher.rs     # File system watcher
│   └── bin/
│       └── cctop_hook.rs  # Hook binary
├── menubar/           # Swift/SwiftUI menubar app
│   ├── CctopMenubar.xcodeproj/
│   ├── CctopMenubar/
│   │   ├── CctopApp.swift         # MenuBarExtra entry point
│   │   ├── Models/                # Session, SessionStatus (Codable)
│   │   ├── Views/                 # PopupView, SessionCardView, etc.
│   │   └── Services/              # SessionManager, FocusTerminal
│   └── CctopMenubarTests/
├── plugins/cctop/     # Claude Code plugin
└── scripts/
    └── bundle-macos.sh   # Build hybrid .app bundle
```

**Step 3: Update Binaries section**

```markdown
### Binaries
- `cctop` - TUI application (Rust, ratatui)
- `cctop-hook` - Hook handler called by Claude Code (Rust)
- `CctopMenubar.app` - macOS menubar app (Swift/SwiftUI, built via Xcode)
```

**Step 4: Add "Rendering Gotchas" note about SwiftUI**

Remove the old egui deadlock and PreMultiplied alpha warnings. Replace with:
```markdown
### Visual Changes
- Use Xcode Previews (Canvas) for instant visual feedback on any view
- All views have `#Preview` blocks with mock data for different states
- For AI agents: XcodeBuildMCP + Xcode MCP bridge enable building and capturing Preview screenshots from Claude Code
```

**Step 5: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: finalize CLAUDE.md for Swift menubar architecture"
```

---

## Phase 4: CI

### Task 15: Update CI for hybrid repo

**Files:**
- Modify: `.github/workflows/ci.yml`

**Step 1: Update CI to test both Rust and Swift**

```yaml
name: CI

on:
  push:
    branches: [master]
  pull_request:

jobs:
  rust-lint:
    name: Rust Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
      - run: cargo fmt --check
      - run: cargo clippy -- -D warnings

  rust-test:
    name: Rust Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo test

  swift-test:
    name: Swift Build & Test
    runs-on: macos-15
    steps:
      - uses: actions/checkout@v4
      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_16.2.app
      - name: Build
        run: xcodebuild build -project menubar/CctopMenubar.xcodeproj -scheme CctopMenubar -configuration Debug -derivedDataPath menubar/build/ CODE_SIGN_IDENTITY="-"
      - name: Test
        run: xcodebuild test -project menubar/CctopMenubar.xcodeproj -scheme CctopMenubar -configuration Debug -derivedDataPath menubar/build/
```

**Step 2: Verify CI passes**

Push the branch and check GitHub Actions.

**Step 3: Commit**

```bash
git add .github/workflows/ci.yml
git commit -m "ci: add Swift build and test job alongside Rust"
```

---

## Phase 5: Apple Developer Program & Signed Releases (Future)

These tasks are deferred until the user validates the Swift rewrite works well.

### Task 16: Enroll in Apple Developer Program

- Sign up at https://developer.apple.com/programs/ ($99/year)
- Create a "Developer ID Application" certificate
- Export as .p12 file for CI

### Task 17: Add signing to release workflow

- Store .p12 certificate as GitHub secret (`APPLE_CERTIFICATE_P12`)
- Store certificate password as GitHub secret
- Store Apple ID, app-specific password, and Team ID as secrets
- Update release workflow to:
  1. Import certificate into CI keychain
  2. Build with `CODE_SIGN_IDENTITY="Developer ID Application: ..."`
  3. Notarize with `xcrun notarytool submit --wait`
  4. Staple with `xcrun stapler staple`
  5. Create DMG with `create-dmg`

### Task 18: Submit to official homebrew-cask

- Once notarized, submit PR to `homebrew/homebrew-cask` with the Cask formula
- This removes the need for the custom tap

---

## Future Revisit Items

- **TUI maintenance**: Evaluate whether to keep `tui.rs` long-term or focus entirely on the menubar app
- **Hook binary language**: Consider rewriting cctop-hook in Swift for single-language simplicity (trade-off: ~30-50ms startup penalty)
- **Context compacted indicator**: The `[compacted]` branch suffix in Rust popup — decide if/how to show this in SwiftUI

---

## Claude Code Setup for Swift Development

Before starting, install these tools:

```bash
# XcodeBuildMCP — build/test Xcode projects from Claude Code
claude mcp add XcodeBuildMCP -- npx -y xcodebuildmcp@beta mcp

# Xcode MCP bridge (Apple official) — Xcode tools + SwiftUI Preview screenshots
claude mcp add --transport stdio xcode -- xcrun mcpbridge
```

Recommended skills:
- SwiftUI Agent Skill (AvdLee): https://github.com/AvdLee/SwiftUI-Agent-Skill
- Axiom (CharlesWiltgen): https://github.com/CharlesWiltgen/Axiom
